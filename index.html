<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>.lys æ­Œè¯é¡ºåºç¼–è¾‘å™¨ï¼ˆæ‹–æ”¾ç‰ˆï¼‰</title>
  <!-- å¯é€‰ï¼šä¸ºè·¨åŸŸåç«¯æä¾› API åŸºå€ï¼Œä¾‹å¦‚ https://your-backend.example.com -->
  <meta name="api-base" content="" />
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #1f2328;
      --muted: #6b7280;
      --border: #e5e7eb;
      --shadow: 0 1px 2px rgba(0,0,0,0.04), 0 4px 12px rgba(0,0,0,0.06);
      --primary: #2563eb;
      --primary-600: #1d4ed8;
      --primary-50: #eff6ff;
      --accent: #8b5cf6;
      --accent-50: #f5f3ff;
      --radius: 10px;
      --radius-sm: 8px;
      --radius-xs: 6px;
      --token: #f9fafb;
      --token-border: #e5e7eb;
      --token-hover: #eef2ff;
      --token-selected: #f3e8ff;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b0f15;
        --card: #0f1722;
        --text: #e5e7eb;
        --muted: #9aa4b2;
        --border: #1f2937;
        --shadow: 0 1px 2px rgba(0,0,0,0.5), 0 8px 24px rgba(0,0,0,0.45);
        --primary: #3b82f6;
        --primary-600: #2563eb;
        --primary-50: #0b1220;
        --accent: #a78bfa;
        --accent-50: #141327;
        --token: #0f1722;
        --token-border: #1f2937;
        --token-hover: #111827;
        --token-selected: #18122b;
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans', Arial, 'PingFang SC', 'Hiragino Sans GB', sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 800px at 10% -10%, rgba(37,99,235,0.05), transparent 40%),
                  radial-gradient(900px 600px at 100% 0%, rgba(139,92,246,0.06), transparent 45%),
                  var(--bg);
    }

    header {
      position: sticky; top: 0; z-index: 20;
      padding: 14px 18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.75)) no-repeat,
                  var(--card);
      backdrop-filter: saturate(1.2) blur(6px);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    @media (prefers-color-scheme: dark) {
      header { background: linear-gradient(180deg, rgba(15,23,34,0.8), rgba(15,23,34,0.75)) no-repeat, var(--card); }
    }

    h1 { margin: 0 0 10px 0; font-size: 20px; font-weight: 650; letter-spacing: 0.2px; }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .controls input[type=file] {
      padding: 6px 8px; border: 1px dashed var(--border); border-radius: var(--radius-xs);
      background: var(--card); color: var(--muted);
    }
    .controls button {
      padding: 8px 12px; border: 1px solid var(--border); background: var(--card);
      border-radius: var(--radius); cursor: pointer; color: var(--text);
      transition: background .2s ease, border-color .2s ease, box-shadow .2s ease, transform .06s ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    .controls button:hover { border-color: #cbd5e1; box-shadow: 0 4px 10px rgba(2,6,23,0.05); }
    .controls button:active { transform: translateY(1px); }
    .controls button:disabled { opacity: 0.6; cursor: not-allowed; }
    /* Primary emphasis */
    #btnImport, #btnExport {
      background: linear-gradient(180deg, var(--primary), var(--primary-600));
      color: #fff; border-color: transparent; box-shadow: 0 6px 18px rgba(37,99,235,0.25);
    }
    #btnImport:hover, #btnExport:hover { box-shadow: 0 8px 22px rgba(37,99,235,0.3); }
    #btnImport:disabled, #btnExport:disabled { background: #aab4c6; box-shadow: none; }

    main {
      display: grid; grid-template-columns: minmax(0, 1fr) 360px; gap: 18px; padding: 18px; max-width: 1200px; margin: 0 auto;
    }
    @media (max-width: 980px) {
      main { grid-template-columns: 1fr; }
    }

    .panel {
      border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; background: var(--card);
      box-shadow: var(--shadow);
    }
    .panel > h2 { margin: 2px 0 10px; font-size: 16px; color: var(--muted); font-weight: 600; }

    #docInfo { color: var(--muted); margin-bottom: 10px; font-size: 13px; }

    #lines { display: flex; flex-direction: column; gap: 10px; }

    .line {
      display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
      padding: 10px; border: 1px dashed var(--border); border-radius: var(--radius-sm);
      background: color-mix(in srgb, var(--card) 92%, transparent);
      transition: border-color .2s ease, background .2s ease, box-shadow .2s ease;
    }
    .line:hover { border-color: #cbd5e1; box-shadow: 0 2px 10px rgba(2,6,23,0.04); }
    .line.meta { background: var(--primary-50); border-style: solid; }

    .prefix { color: var(--muted); margin-right: 6px; font-variant-numeric: tabular-nums; }

    .tok {
      display: inline-block; padding: 6px 10px; border: 1px solid var(--token-border);
      border-radius: 999px; cursor: grab; user-select: none;
      background: var(--token); color: var(--text);
      transition: border-color .15s ease, box-shadow .15s ease, background .15s ease, transform .06s ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
      outline: none;
    }
    .tok:hover { border-color: #c7d2fe; background: var(--token-hover); }
    .tok:active { cursor: grabbing; transform: translateY(1px); }
    .tok.selected {
      background: var(--token-selected);
      border-color: #c084fc;
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent);
    }
    .tok.anchor { outline: 2px solid var(--primary); }
    .tok:focus-visible { box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 30%, transparent); }

    .tok.drop-left { box-shadow: -3px 0 0 0 var(--primary) inset, 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
    .tok.drop-right { box-shadow:  3px 0 0 0 var(--primary) inset, 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }

    .box { background: linear-gradient(180deg, var(--accent-50), transparent 80%); padding: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); }
    #status { margin-top: 10px; color: var(--muted); min-height: 1.4em; font-size: 13px; }
    .muted { color: var(--muted); font-size: 12px; }

    /* Smooth scrollbars */
    ::-webkit-scrollbar { height: 10px; width: 10px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 999px; }
    ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

    /* Line drop highlight */
    .line.drop-left { box-shadow: inset 4px 0 0 0 var(--primary); border-style: solid; }
    .line.drop-right { box-shadow: inset -4px 0 0 0 var(--primary); border-style: solid; }
    .line.selected { border-color: #93c5fd; background: color-mix(in srgb, var(--primary-50) 65%, var(--card)); }

    /* Prefix editor */
    .prefix-editor { width: 64px; min-width: 56px; padding: 4px 6px; border: 1px dashed var(--border); border-radius: 7px; background: var(--card); color: var(--text); text-align: center; font-variant-numeric: tabular-nums; }
    .prefix-editor::placeholder { color: var(--muted); }
    .prefix-editor:focus { outline: none; border-color: #cbd5e1; box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
    /* Playing highlight */
    .tok.active {
      background: #fef3c7; /* amber-100 */
      border-color: #f59e0b; /* amber-500 */
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25);
    }
    .line.playing {
      outline: 2px solid rgba(245, 158, 11, 0.35);
    }
  </style>
</head>
<body>
  <header>
    <h1>.lys æ­Œè¯é¡ºåºç¼–è¾‘å™¨ï¼ˆå¤šé€‰æ‹–æ”¾ï¼Œå‰ç«¯ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰</h1>
    <div class="controls">
      <input type="file" id="fileInput" accept=".lys,.lrc,.txt" />
      <button id="btnImport">å¯¼å…¥ .lys</button>
      <button id="btnUndo" disabled>æ’¤é”€</button>
      <button id="btnRedo" disabled>é‡åš</button>
      <button id="btnSortLines" disabled>æ’åºæ­Œè¯è¡Œ</button>
      <button id="btnExport" disabled>å¯¼å‡º .lys</button>
      <span style="flex:1"></span>
      <!-- æ–°å¢ï¼šæŒ‰é”®å»¶è¿Ÿ(ms) è®¾ç½® -->
      <label class="muted" style="display:flex; align-items:center; gap:6px;">
        å»¶è¿Ÿ(ms)
        <input id="keyDelayInput" type="number" step="1" placeholder="0"
               style="width:90px; padding:4px 6px; border:1px dashed var(--border); border-radius:6px;">
      </label>
      <input type="file" id="mediaInput" accept="audio/*,video/*" />
      <button id="btnPlayPause" disabled>æ’­æ”¾</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2>æ–‡æ¡£</h2>
      <div id="docInfo"></div>
      <div id="lines"></div>
    </section>

    <section class="panel">
      <h2>ç”¨æ³•è¯´æ˜</h2>
      <div class="box">
        <h3 style="margin-top: 0; color: var(--primary);">ğŸµ åŸºç¡€æ“ä½œ</h3>
        <p><strong>é€‰æ‹©æ­Œè¯å—ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>å•å‡»ä¸€ä¸ªæ­Œè¯å—è¿›è¡Œå•é€‰</li>
          <li><strong>Ctrl/âŒ˜ + ç‚¹å‡»</strong>è¿›è¡Œå¤šé€‰ï¼ˆå¯è·¨è¡Œé€‰æ‹©ï¼‰</li>
          <li>ç‚¹å‡»ç©ºç™½å¤„æ¸…ç©ºæ‰€æœ‰é€‰æ‹©</li>
        </ul>
        
        <p><strong>æ‹–æ”¾è°ƒæ•´é¡ºåºï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>é€‰ä¸­æ–‡æœ¬å—åç›´æ¥æ‹–åŠ¨åˆ°ç›®æ ‡ä½ç½®</li>
          <li>æ‹–åŠ¨åˆ°å¦ä¸€ä¸ªå—çš„å·¦åŠåŒºï¼šæ’å…¥åˆ°è¯¥å—å‰é¢</li>
          <li>æ‹–åŠ¨åˆ°å¦ä¸€ä¸ªå—çš„å³åŠåŒºï¼šæ’å…¥åˆ°è¯¥å—åé¢</li>
          <li>æ‹–åŠ¨åˆ°è¡Œçš„å·¦åŠåŒºï¼šç§»åŠ¨åˆ°è¯¥è¡Œå¼€å¤´</li>
          <li>æ‹–åŠ¨åˆ°è¡Œçš„å³åŠåŒºï¼šç§»åŠ¨åˆ°è¯¥è¡Œç»“å°¾</li>
          <li class="muted">æ‹–æ”¾æ—¶ä¼šæœ‰è“è‰²é«˜äº®æç¤ºæ’å…¥ä½ç½®</li>
        </ul>
        
        <h3 style="color: var(--primary);">âœï¸ ç¼–è¾‘åŠŸèƒ½</h3>
        <p><strong>å¤åˆ¶ç²˜è´´ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>Ctrl+C / Ctrl+Vï¼ˆMac: âŒ˜C / âŒ˜Vï¼‰å¤åˆ¶ç²˜è´´</li>
          <li>å¯å¤åˆ¶å•ä¸ªè¯å—æˆ–å¤šé€‰è¯å—</li>
          <li>å¯å¤åˆ¶æ•´è¡Œæ­Œè¯ï¼ˆå…ˆç‚¹å‡»è¡Œç©ºç™½å¤„ï¼‰</li>
          <li>ç²˜è´´åˆ°è¯å—å³ä¾§æˆ–è¡Œå¼€å¤´</li>
        </ul>
        
        <p><strong>å‰ç¼€ç¼–è¾‘ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>æ­Œè¯è¡Œå·¦ä¾§çš„æ•°å­—å‰ç¼€å¯ç›´æ¥ç¼–è¾‘</li>
          <li>è¾“å…¥æ•°å­—åæŒ‰ Enter æˆ–ç‚¹å‡»å…¶ä»–åœ°æ–¹ç¡®è®¤</li>
          <li>ç•™ç©ºåˆ™æ˜¾ç¤ºä¸º []ï¼ˆæ— å‰ç¼€ï¼‰</li>
        </ul>
        
        <p><strong>æ’å…¥ç©ºè¡Œï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>åŒå‡»ä»»æ„è¡Œç©ºç™½å¤„åœ¨è¯¥è¡Œä¸‹æ–¹æ’å…¥æ–°ç©ºè¡Œ</li>
          <li>æ–°æ’å…¥çš„ç©ºè¡Œå¯ç¼–è¾‘å‰ç¼€å’Œæ·»åŠ å†…å®¹</li>
        </ul>
        
        <h3 style="color: var(--primary);">ğŸ® æ’­æ”¾æ§åˆ¶</h3>
        <p><strong>æ’­æ”¾å™¨åŠŸèƒ½ï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>å¯é€‰åŠ è½½ éŸ³é¢‘/è§†é¢‘ æ–‡ä»¶è¿›è¡ŒåŒæ­¥æ’­æ”¾</li>
          <li>ç‚¹å‡»ã€Œæ’­æ”¾ã€æŒ‰é’®æˆ–æŒ‰ç©ºæ ¼é”®æ’­æ”¾/æš‚åœ</li>
          <li>å•å‡»ä»»æ„ä¸€è¡Œå¯ä»è¯¥è¡Œå¼€å§‹æ’­æ”¾</li>
          <li>å½“å‰æ’­æ”¾çš„æ­Œè¯è¡Œå’Œè¯å—ä¼šé«˜äº®æ˜¾ç¤º</li>
          <li>ä¸åŠ è½½åª’ä½“æ–‡ä»¶æ—¶ä½¿ç”¨æ—¶é’Ÿæ¨¡å¼æ’­æ”¾</li>
        </ul>
        
        <h3 style="color: var(--primary);">ğŸ› ï¸ é«˜çº§åŠŸèƒ½</h3>
        <p><strong>æ’¤é”€é‡åšï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>ä½¿ç”¨ã€Œæ’¤é”€ã€å’Œã€Œé‡åšã€æŒ‰é’®æ¢å¤æ“ä½œ</li>
          <li>æ”¯æŒå¤šæ­¥æ’¤é”€å’Œé‡åš</li>
        </ul>
        
        <p><strong>æ­Œè¯è¡Œæ’åºï¼š</strong></p>
        <ul style="margin: 8px 0; padding-left: 20px;">
          <li>ç‚¹å‡»ã€Œæ’åºæ­Œè¯è¡Œã€æŒ‰å¼€å§‹æ—¶é—´è‡ªåŠ¨æ’åº</li>
          <li>ä¿ç•™åŸæœ‰æ—¶é—´æˆ³ï¼Œåªè°ƒæ•´è¡Œçš„å…ˆåé¡ºåº</li>
        </ul>
        
        <h3 style="color: var(--primary);">ğŸ“ æ–‡ä»¶æ”¯æŒ</h3>
        <p><strong>å¯¼å…¥æ ¼å¼ï¼š</strong> .lysã€.lrcã€.txt æ–‡ä»¶</p>
        <p><strong>å¯¼å‡ºæ ¼å¼ï¼š</strong> ä¿æŒåŸå§‹ .lys æ ¼å¼ï¼Œæ—¶é—´æˆ³å®Œæ•´ä¿ç•™</p>
        <p class="muted">ğŸ’¡ æç¤ºï¼šé¡µé¢ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œä½†æ‰€æœ‰æ“ä½œéƒ½ä¼šä¿ç•™åŸæ—¶é—´æˆ³ï¼›å¯¼å‡ºæ—¶æ—¶é—´æˆ³ä¼šå®Œæ•´ä¿ç•™ã€‚</p>
        
        <h3 style="color: var(--primary);">âŒ¨ï¸ å¿«æ·é”®</h3>
        <div style="background: var(--primary-50); padding: 12px; border-radius: 8px; margin-top: 12px;">
          <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">Ctrl+C / âŒ˜C</td>
              <td style="padding: 6px 8px; color: var(--muted);">å¤åˆ¶é€‰ä¸­çš„æ­Œè¯å†…å®¹</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">Ctrl+V / âŒ˜V</td>
              <td style="padding: 6px 8px; color: var(--muted);">ç²˜è´´åˆ°é€‰ä¸­çš„ä½ç½®</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">Space (ç©ºæ ¼)</td>
              <td style="padding: 6px 8px; color: var(--muted);">æ’­æ”¾/æš‚åœ</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border);">
              <td style="padding: 6px 8px; font-weight: 600;">F</td>
              <td style="padding: 6px 8px; color: var(--muted);">
                è®©"é€‰ä¸­è¡Œ"çš„æ­Œè¯ä»æ­¤åˆ»å¼€å§‹ï¼ˆå«æŒ‰é”®å»¶è¿Ÿï¼‰
              </td>
            </tr>
            <tr>
              <td style="padding: 6px 8px; font-weight: 600;">Ctrl+ç‚¹å‡» / âŒ˜+ç‚¹å‡»</td>
              <td style="padding: 6px 8px; color: var(--muted);">å¤šé€‰æ­Œè¯å—</td>
            </tr>
          </table>
        </div>
      </div>
      <div id="status"></div>
    </section>
  </main>


  <script>
    const $ = (sel) => document.querySelector(sel);
    // API åŸºå€ï¼ˆé»˜è®¤åŒæºï¼‰ã€‚å¯åœ¨éƒ¨ç½²åˆ° GitHub Pages æ—¶ï¼Œé€šè¿‡æ³¨å…¥ window.API_BASE æˆ–è®¾ç½® <meta name="api-base" content="..."> æ¥æŒ‡å®šåç«¯åŸŸåã€‚
    const API_BASE = (window.API_BASE || (document.querySelector('meta[name="api-base"]')?.content || '')).replace(/\/$/, '');
    const apiUrl = (path) => API_BASE + path;
    const apiFetch = (path, init) => fetch(apiUrl(path), init);

    let state = {
      doc: null,
      selectedTokenIds: new Set(),
      selectedLineId: null, // é€‰ä¸­çš„æ•´è¡Œï¼ˆç”¨äºè¡Œçº§å¤åˆ¶/ç²˜è´´ï¼‰
      clipboard: null,      // { tokens: [{text, ts}], fromLineId }
      settings: {
        keyDelayMs: 0,
      },
      // æ’­æ”¾ç›¸å…³
      playback: {
        usingMedia: false,
        mediaEl: null,
        playing: false,
        rafId: 0,
        clockStartEpoch: 0,
        clockStartOffset: 0, // ms
      },
      tokenCache: [], // [{id, lineId, start, end, el}]
    };

    function setStatus(msg) {
      $('#status').textContent = msg || '';
    }

    function renderDoc() {
      const c = $('#lines');
      c.innerHTML = '';
      if (!state.doc) return;
      $('#docInfo').textContent = `DocID: ${state.doc.id} â€” version: ${state.doc.version} â€” è¡Œæ•°: ${state.doc.lines.length}`;

      state.tokenCache = [];
      state.doc.lines.forEach((line) => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'line' + (line.is_meta ? ' meta' : '');
        lineDiv.dataset.lineId = line.id;
        if (state.selectedLineId === line.id) lineDiv.classList.add('selected');

        // å¯ç¼–è¾‘çš„å‰ç¼€æ•°å­—è¾“å…¥ï¼ˆä»…é meta è¡Œï¼‰
        if (!line.is_meta) {
          const preWrap = document.createElement('div');
          preWrap.className = 'prefix';
          const input = document.createElement('input');
          input.className = 'prefix-editor';
          input.type = 'number';
          input.placeholder = '[ ]';
          const m = /\[([^\]]*)\]/.exec(line.prefix || '');
          input.value = m ? m[1] : '';
          input.title = 'å¯ç¼–è¾‘çš„å‰ç¼€æ•°å­—ï¼ˆç•™ç©ºä¸ºæ— å‰ç¼€ï¼‰';
          input.addEventListener('click', (e) => { e.stopPropagation(); });
          input.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') { await commitPrefix(line.id, input.value); }
            e.stopPropagation();
          });
          input.addEventListener('blur', async () => { await commitPrefix(line.id, input.value); });
          preWrap.appendChild(input);
          lineDiv.appendChild(preWrap);
        } else if (line.prefix) {
          const pre = document.createElement('span');
          pre.className = 'prefix';
          pre.textContent = line.prefix;
          lineDiv.appendChild(pre);
        }

        line.tokens.forEach((tok) => {
          const span = document.createElement('span');
          span.className = 'tok';
          // ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œåªæ˜¾ç¤ºæ–‡æœ¬
          span.textContent = tok.text || '(ç©º)';
          span.title = `tokenId=${tok.id}`; // ä¸æ˜¾ç¤ºæ—¶é—´æˆ³
          span.dataset.tokenId = tok.id;
          span.dataset.lineId = line.id;
          span.draggable = !line.is_meta;  // meta è¡Œä¸å…è®¸æ‹–æ‹½

          // è§£ææ—¶é—´æˆ³ï¼ˆstart,durationï¼‰
          let sMs = null, dMs = null;
          if (tok.ts && typeof tok.ts === 'string' && tok.ts.includes(',')) {
            const parts = tok.ts.split(',');
            sMs = parseInt(parts[0], 10);
            dMs = parseInt(parts[1], 10);
            if (!Number.isFinite(sMs) || !Number.isFinite(dMs)) { sMs = null; dMs = null; }
          }
          if (sMs != null && dMs != null) {
            span.dataset.startMs = String(sMs);
            span.dataset.durMs = String(dMs);
            state.tokenCache.push({ id: tok.id, lineId: line.id, start: sMs, end: sMs + dMs, el: span });
          }

          if (state.selectedTokenIds.has(tok.id)) span.classList.add('selected');

          // ç‚¹å‡»ï¼šå¤šé€‰/å–æ¶ˆ
          span.addEventListener('click', (e) => {
            const multi = e.metaKey || e.ctrlKey;
            if (multi) {
              if (state.selectedTokenIds.has(tok.id)) state.selectedTokenIds.delete(tok.id);
              else state.selectedTokenIds.add(tok.id);
            } else {
              // å•å‡»åˆ‡æ¢é€‰æ‹©åˆ°è¿™ä¸ª tokenï¼ˆä¾¿äºå•é€‰æ‹–åŠ¨ï¼‰
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
            }
            renderDoc();
          });

          // æ‹–æ‹½å¼€å§‹ï¼šè‹¥å½“å‰ token ä¸åœ¨é€‰æ‹©ä¸­ï¼Œåˆ™å°†é€‰æ‹©é‡ç½®ä¸ºè¯¥ token
          span.addEventListener('dragstart', (e) => {
            if (!state.selectedTokenIds.has(tok.id)) {
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
              renderDoc();
            }
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', 'drag'); // å ä½ä»¥å¯ç”¨æ‹–æ‹½
          });

          // åœ¨ token ä¸Šæ–¹æ‚¬åœï¼šå†³å®š before / after çš„è§†è§‰æç¤º
          span.addEventListener('dragover', (e) => {
            if (!state.doc) return;
            e.preventDefault(); // å…è®¸ drop
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.toggle('drop-left', isLeft);
            span.classList.toggle('drop-right', !isLeft);
          });

          // ç¦»å¼€æ—¶æ¸…ç†æ ·å¼
          span.addEventListener('dragleave', () => {
            span.classList.remove('drop-left', 'drop-right');
          });

          // æ”¾ä¸‹ï¼šè®¡ç®— before/afterï¼Œæ„é€  selection + targetï¼Œè°ƒç”¨ /api/move
          span.addEventListener('drop', async (e) => {
            e.preventDefault();
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.remove('drop-left', 'drop-right');
            await doDropMove({
              anchorLineId: span.dataset.lineId,
              anchorTokenId: span.dataset.tokenId,
              position: isLeft ? 'before' : 'after',
            });
          });

          lineDiv.appendChild(span);
        });

        // è¡Œçº§äº¤äº’ï¼šé€‰æ‹©è¡Œã€è¡Œçº§æ‹–æ”¾ï¼ˆåˆ°å¤´/å°¾ï¼‰ã€åŒå‡»æ’å…¥ç©ºè¡Œ
        if (!line.is_meta) {
          lineDiv.addEventListener('click', (e) => {
            if (e.target.classList.contains('tok') || e.target.classList.contains('prefix-editor')) return;
            state.selectedTokenIds.clear();
            state.selectedLineId = line.id;
            renderDoc();
            // å•å‡»è¡Œï¼šä»è¯¥è¡Œå¼€å§‹æ’­æ”¾
            startFromLine(line.id);
          });

          lineDiv.addEventListener('dblclick', async (e) => {
            e.preventDefault();
            await insertEmptyLineBelow(line.id);
          });

          lineDiv.addEventListener('dragover', (e) => {
            if (!state.doc) return; e.preventDefault();
            const rect = lineDiv.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            lineDiv.classList.toggle('drop-left', isLeft);
            lineDiv.classList.toggle('drop-right', !isLeft);
          });
          lineDiv.addEventListener('dragleave', () => {
            lineDiv.classList.remove('drop-left', 'drop-right');
          });
          lineDiv.addEventListener('drop', async (e) => {
            e.preventDefault();
            const rect = lineDiv.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            lineDiv.classList.remove('drop-left', 'drop-right');
            await doDropMoveLine({ lineId: line.id, position: isLeft ? 'start' : 'end' });
          });
        }

        c.appendChild(lineDiv);
      });
      // æ¸²æŸ“ååˆ·æ–°ä¸€æ¬¡é«˜äº®ï¼ˆä¿æŒæ’­æ”¾ä¸­æ—¶ UI åŒæ­¥ï¼‰
      updateHighlight(getNowMs());
    }

    // å°†é€‰ä¸­çš„ token ID é›†åˆåˆå¹¶æˆè‹¥å¹²ä¸ª [start_id, end_id] çš„è¿ç»­åŒºé—´ï¼ˆé€è¡Œï¼‰
    function groupSelectionIntoRanges() {
      if (!state.doc) return [];
      const idToIndex = new Map();
      state.doc.lines.forEach((line, li) => {
        line.tokens.forEach((tok, ti) => {
          idToIndex.set(tok.id, { li, ti, line_id: line.id });
        });
      });

      const selected = Array.from(state.selectedTokenIds)
        .map((id) => idToIndex.get(id))
        .filter(Boolean)
        .sort((a, b) => (a.li - b.li) || (a.ti - b.ti));

      const ranges = [];
      let i = 0;
      while (i < selected.length) {
        const { li, line_id } = selected[i];
        let startTi = selected[i].ti;
        let endTi = startTi;

        let j = i + 1;
        while (j < selected.length && selected[j].li === li && selected[j].ti === endTi + 1) {
          endTi = selected[j].ti;
          j++;
        }
        const line = state.doc.lines[li];
        const start_token_id = line.tokens[startTi].id;
        const end_token_id = line.tokens[endTi].id;
        ranges.push({ line_id, start_token_id, end_token_id });
        i = j;
      }
      return ranges;
    }

    async function doDropMove({ anchorLineId, anchorTokenId, position }) {
      if (!state.doc) return;
      const selectionRanges = groupSelectionIntoRanges();
      if (selectionRanges.length === 0) {
        setStatus('è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„æ­Œè¯å—ï¼ˆå¯ Ctrl/âŒ˜ å¤šé€‰ï¼‰');
        return;
      }

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        selection: selectionRanges,
        target: {
          type: 'anchor',
          line_id: anchorLineId,
          anchor_token_id: anchorTokenId,
          position: position // 'before' | 'after'
        }
      };

      const res = await apiFetch('/api/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setStatus('ç§»åŠ¨å¤±è´¥ï¼š' + text);
        return;
      }
      const doc = await res.json();
      state.doc = doc;
      // æˆåŠŸåé»˜è®¤æ¸…ç©ºé€‰æ‹©ï¼Œé¿å…è¯¯æ‹–
      state.selectedTokenIds.clear();
      renderDoc();
      setStatus('å·²å®Œæˆæ‹–æ”¾ç§»åŠ¨ã€‚');
    }

    async function doDropMoveLine({ lineId, position }) {
      if (!state.doc) return;
      const selectionRanges = groupSelectionIntoRanges();
      if (selectionRanges.length === 0) { setStatus('è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„æ­Œè¯å—ï¼ˆå¯ Ctrl/âŒ˜ å¤šé€‰ï¼‰'); return; }

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        selection: selectionRanges,
        target: { type: 'line', line_id: lineId, position } // 'start' | 'end'
      };
      const res = await apiFetch('/api/move', {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
      });
      if (!res.ok) { const text = await res.text(); setStatus('ç§»åŠ¨å¤±è´¥ï¼š' + text); return; }
      const doc = await res.json();
      state.doc = doc; state.selectedTokenIds.clear(); renderDoc(); setStatus('å·²å®Œæˆæ‹–æ”¾ç§»åŠ¨ã€‚');
    }

    async function insertEmptyLineBelow(afterLineId) {
      const res = await apiFetch('/api/newline', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, insert_after_line_id: afterLineId })
      });
      if (!res.ok) { const text = await res.text(); setStatus('æ’å…¥ç©ºè¡Œå¤±è´¥ï¼š' + text); return; }
      const doc = await res.json(); state.doc = doc; renderDoc(); setStatus('å·²æ’å…¥ç©ºè¡Œã€‚');
    }

    async function commitPrefix(lineId, value) {
      if (!state.doc) return;
      const v = String(value || '').trim();
      const res = await apiFetch('/api/set_prefix', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, line_id: lineId, prefix_int: v === '' ? "" : v })
      });
      if (!res.ok) { return; }
      const doc = await res.json(); state.doc = doc; renderDoc();
    }

    function collectSelectedTokens() {
      if (!state.doc) return [];
      const idToTok = new Map();
      const order = [];
      state.doc.lines.forEach((line, li) => {
        line.tokens.forEach((tok, ti) => {
          idToTok.set(tok.id, { tok, li, ti, line_id: line.id });
          order.push({ id: tok.id, li, ti });
        });
      });
      const arr = Array.from(state.selectedTokenIds).map(id => idToTok.get(id)).filter(Boolean);
      arr.sort((a,b)=> (a.li-b.li)||(a.ti-b.ti));
      return arr;
    }

    function handleCopy() {
      const sels = collectSelectedTokens();
      if (sels.length > 0) {
        const tokens = sels.map(s => ({ text: s.tok.text, ts: s.tok.ts }));
        state.clipboard = { tokens, fromLineId: sels[0].line_id };
        setStatus('å·²å¤åˆ¶æ‰€é€‰æ­Œè¯å—ã€‚');
        return true;
      }
      if (state.selectedLineId) {
        const line = state.doc.lines.find(ln => ln.id === state.selectedLineId);
        if (line && !line.is_meta && line.tokens.length) {
          const tokens = line.tokens.map(t => ({ text: t.text, ts: t.ts }));
          state.clipboard = { tokens, fromLineId: line.id };
          setStatus('å·²å¤åˆ¶æ•´è¡Œæ­Œè¯ã€‚');
          return true;
        }
      }
      setStatus('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹');
      return false;
    }

    async function handlePaste() {
      if (!state.clipboard || !state.doc) { setStatus('å‰ªè´´æ¿ä¸ºç©º'); return; }
      const items = state.clipboard.tokens || [];
      if (items.length === 0) { setStatus('å‰ªè´´æ¿ä¸ºç©º'); return; }

      // ä¼˜å…ˆï¼šè‹¥é€‰ä¸­äº† tokenï¼Œåˆ™ç²˜è´´åˆ°å…¶å³è¾¹ï¼ˆå–è¯¥è¡Œä¸­é€‰ä¸­çš„æœ€å³ä¸€ä¸ª token ç´¢å¼•+1ï¼‰
      const sels = collectSelectedTokens();
      if (sels.length > 0) {
        const lineId = sels[0].line_id;
        const line = state.doc.lines.find(ln => ln.id === lineId);
        const lastTi = Math.max(...sels.filter(s=>s.line_id===lineId).map(s=>s.ti));
        await insertTokens(lineId, lastTi + 1, items);
        return;
      }
      // å¦åˆ™ï¼šè‹¥é€‰ä¸­è¡Œï¼Œåˆ™ç²˜è´´åˆ°è¯¥è¡Œæœ€å·¦
      if (state.selectedLineId) {
        await insertTokens(state.selectedLineId, 0, items);
        return;
      }
      setStatus('è¯·å…ˆé€‰ä¸­ä¸€ä¸ªç›®æ ‡ï¼ˆtokenæˆ–è¡Œï¼‰å†ç²˜è´´');
    }

    async function insertTokens(lineId, insertAt, tokens) {
      const res = await apiFetch('/api/insert_tokens', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, line_id: lineId, insert_at: insertAt, tokens })
      });
      if (!res.ok) { const text = await res.text(); setStatus('ç²˜è´´å¤±è´¥ï¼š' + text); return; }
      const doc = await res.json(); state.doc = doc; state.selectedTokenIds.clear(); renderDoc(); setStatus('å·²ç²˜è´´ã€‚');
    }

    // ---- åŸºç¡€ API è°ƒç”¨ï¼ˆå¯¼å…¥ã€å¯¼å‡ºã€æ’¤é”€ã€é‡åšï¼‰ ----
    async function importLys(file) {
      const fd = new FormData();
      fd.append('file', file);
      const res = await apiFetch('/api/import', { method: 'POST', body: fd });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || 'å¯¼å…¥å¤±è´¥');
      }
      const doc = await res.json();
      state.doc = doc;
      state.selectedTokenIds.clear();
      renderDoc();
      $('#btnExport').disabled = false;
      $('#btnUndo').disabled = false;
      $('#btnRedo').disabled = false;
      $('#btnSortLines').disabled = false;
      // å…è®¸åœ¨æ— åª’ä½“æ–‡ä»¶æ—¶ä½¿ç”¨æ—¶é’Ÿæ’­æ”¾
      $('#btnPlayPause').disabled = false;
    }

    async function exportLys() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/export?' + params.toString(), { method: 'GET' });
      const text = await res.text();
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'edited.lys';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    async function undo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/undo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('æ— æ³•æ’¤é”€'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
    }

    async function redo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/redo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('æ— æ³•é‡åš'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
    }

    async function sortLines() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥æ–‡æ¡£'); return; }
      
      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version
      };
      
      const res = await apiFetch('/api/sort_lines', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (!res.ok) {
        const text = await res.text();
        setStatus('æ’åºå¤±è´¥ï¼š' + text);
        return;
      }
      
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
      setStatus('æ­Œè¯è¡Œå·²æŒ‰æ—¶é—´é¡ºåºæ’åºå®Œæˆ');
    }

    // ======== æ’­æ”¾å™¨é€»è¾‘ ========
    function ensureMediaEl() {
      if (!state.playback.mediaEl) {
        const v = document.createElement('video');
        v.id = 'player';
        v.controls = true; // å…è®¸ç”¨æˆ·æ§åˆ¶
        v.style.maxWidth = '100%';
        v.style.display = 'block';
        v.style.marginTop = '10px';
        // æ”¾åˆ°ç”¨æ³•é¢æ¿ä¸‹ï¼ˆæ›´è‡ªç„¶ï¼‰
        const panel = document.querySelectorAll('.panel')[1];
        panel.appendChild(v);
        state.playback.mediaEl = v;
        // å½“åª’ä½“æ’­æ”¾/æš‚åœæ—¶ï¼ŒåŒæ­¥æŒ‰é’®çŠ¶æ€
        v.addEventListener('play', () => { state.playback.playing = true; startLoop(); syncPlayButton(); });
        v.addEventListener('pause', () => { state.playback.playing = false; stopLoop(); syncPlayButton(); });
        v.addEventListener('seeked', () => { updateHighlight(getNowMs()); });
        v.addEventListener('timeupdate', () => { updateHighlight(getNowMs()); });
        v.addEventListener('ended', () => { state.playback.playing = false; stopLoop(); syncPlayButton(); });
      }
      return state.playback.mediaEl;
    }

    function loadMediaFile(file) {
      const v = ensureMediaEl();
      const url = URL.createObjectURL(file);
      v.src = url;
      v.load();
      state.playback.usingMedia = true;
      $('#btnPlayPause').disabled = false;
      setStatus('å·²åŠ è½½åª’ä½“ï¼š' + (file.name || '')); 
    }

    function getNowMs() {
      if (state.playback.usingMedia && state.playback.mediaEl) {
        return (state.playback.mediaEl.currentTime || 0) * 1000;
      }
      // æ—¶é’Ÿæ¨¡å¼
      return state.playback.clockStartOffset + (state.playback.playing ? (performance.now() - state.playback.clockStartEpoch) : 0);
    }

    function play() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥ .lys'); return; }
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.play();
      } else {
        // æ— åª’ä½“ï¼Œä½¿ç”¨æ—¶é’Ÿ
        state.playback.playing = true;
        state.playback.clockStartEpoch = performance.now();
        startLoop();
        syncPlayButton();
      }
    }

    function pause() {
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.pause();
      } else {
        // æ—¶é’Ÿæš‚åœ
        state.playback.clockStartOffset = getNowMs();
        state.playback.playing = false;
        stopLoop();
        syncPlayButton();
      }
    }

    function togglePlay() {
      if (state.playback.playing) pause(); else play();
    }

    function seekMs(ms) {
      ms = Math.max(0, ms|0);
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.currentTime = ms / 1000;
      } else {
        state.playback.clockStartOffset = ms;
        if (state.playback.playing) state.playback.clockStartEpoch = performance.now();
        updateHighlight(getNowMs());
      }
    }

    function startFromLine(lineId) {
      if (!state.doc) return;
      const line = state.doc.lines.find(l => l.id === lineId);
      if (!line || !line.tokens || line.tokens.length === 0) return;
      // æ‰¾åˆ°è¯¥è¡Œæœ€æ—©çš„ start
      let minStart = Infinity;
      for (const t of line.tokens) {
        if (!t.ts) continue;
        const [s, d] = String(t.ts).split(',').map(x=>parseInt(x,10));
        if (Number.isFinite(s)) minStart = Math.min(minStart, s);
      }
      if (!Number.isFinite(minStart)) return;
      seekMs(minStart);
      // è‹¥æœªæ’­æ”¾åˆ™å¼€å§‹
      if (!state.playback.playing) play();
    }

    function syncPlayButton() {
      $('#btnPlayPause').textContent = state.playback.playing ? 'æš‚åœ' : 'æ’­æ”¾';
    }

    function startLoop() {
      cancelAnimationFrame(state.playback.rafId);
      const loop = () => {
        updateHighlight(getNowMs());
        state.playback.rafId = requestAnimationFrame(loop);
      };
      state.playback.rafId = requestAnimationFrame(loop);
    }

    function stopLoop() {
      cancelAnimationFrame(state.playback.rafId);
    }

    function updateHighlight(nowMs) {
      // é«˜äº® tokenï¼ŒåŠå…¶æ‰€åœ¨è¡Œ
      const activeLines = new Set();
      for (const item of state.tokenCache) {
        const active = nowMs >= item.start && nowMs < item.end;
        item.el.classList.toggle('active', !!active);
        if (active) activeLines.add(item.lineId);
      }
      // è¡Œçº§æ ‡è®°
      document.querySelectorAll('.line').forEach(ln => {
        const lid = ln.dataset.lineId;
        ln.classList.toggle('playing', activeLines.has(lid));
      });
    }

    async function alignSelectedLineToNow() {
      if (!state.doc) { setStatus('è¯·å…ˆå¯¼å…¥ .lys'); return; }
      const lineId = state.selectedLineId;
      if (!lineId) { setStatus('è¯·å…ˆé€‰ä¸­ä¸€æ•´è¡Œï¼ˆç‚¹å‡»è¡Œç©ºç™½å¤„å³å¯é€‰ä¸­è¯¥è¡Œï¼‰'); return; }

      const line = state.doc.lines.find(l => l.id === lineId);
      if (!line || line.is_meta) { setStatus('è¯¥è¡Œä¸å¯å¯¹é½ï¼ˆmetaæˆ–ä¸å­˜åœ¨ï¼‰'); return; }
      if (!line.tokens || line.tokens.length === 0) { setStatus('è¯¥è¡Œæ²¡æœ‰å¯å¯¹é½çš„æ­Œè¯'); return; }

      // æ‰¾åˆ°è¯¥è¡Œ"é¦–ä¸ª"åˆæ³•æ—¶é—´æˆ³çš„å¼€å§‹æ—¶é—´ï¼ˆå–æœ€å° startï¼‰
      let firstStart = Infinity;
      for (const t of line.tokens) {
        const ts = (t.ts || '');
        if (!ts.includes(',')) continue;
        const parts = ts.split(',');
        const s = parseInt(parts[0], 10);
        if (Number.isFinite(s)) firstStart = Math.min(firstStart, s);
      }
      if (!Number.isFinite(firstStart)) { setStatus('è¯¥è¡Œæ²¡æœ‰åˆæ³•æ—¶é—´æˆ³å¯å¯¹é½'); return; }

      const now = getNowMs();
      const delay = Number(state.settings.keyDelayMs || 0);
      const delta = Math.round((now + delay) - firstStart); // è®© firstStart å¯¹é½åˆ° now+delay

      // Î” ä¸º 0 ä¹Ÿå…è®¸æäº¤ï¼Œä»¥ä¾¿è¿›å…¥æ’¤é”€æ ˆï¼›ä½†åšä¸ªæç¤º
      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        line_id: lineId,
        delta_ms: delta
      };

      const res = await apiFetch('/api/shift_line', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setStatus('å¯¹é½å¤±è´¥ï¼š' + text);
        return;
      }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();

      const sign = delta >= 0 ? '+' : '';
      setStatus(`å·²å¯¹é½è¯¥è¡Œåˆ°å½“å‰æ—¶é—´ï¼ˆå»¶è¿Ÿ ${delay|0}msï¼ŒÎ”=${sign}${delta}msï¼‰ã€‚`);
    }

    function init() {
      $('#btnImport').addEventListener('click', async () => {
        const f = $('#fileInput').files[0];
        if (!f) { setStatus('è¯·é€‰æ‹©ä¸€ä¸ª .lys æ–‡ä»¶'); return; }
        try {
          await importLys(f);
          setStatus('å¯¼å…¥æˆåŠŸã€‚');
        } catch (e) {
          setStatus(String(e));
        }
      });

      $('#btnExport').addEventListener('click', exportLys);
      $('#btnUndo').addEventListener('click', undo);
      $('#btnRedo').addEventListener('click', redo);
      $('#btnSortLines').addEventListener('click', sortLines);
      $('#btnPlayPause').addEventListener('click', togglePlay);
      $('#mediaInput').addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (f) loadMediaFile(f);
      });

      // ç‚¹å‡»ç©ºç™½å¤„æ¸…ç©ºé€‰æ‹©
      $('#lines').addEventListener('click', (e) => {
        if (e.target.classList.contains('tok') || e.target.classList.contains('prefix-editor')) return;
        state.selectedTokenIds.clear();
        state.selectedLineId = null;
        renderDoc();
      });

      // â€”â€” æŒ‰é”®å»¶è¿Ÿè®¾ç½® â€”â€” //
      const delayInput = $('#keyDelayInput');
      // è¯»å–æœ¬åœ°ä¿å­˜
      const savedDelay = parseInt(localStorage.getItem('keyDelayMs') || '0', 10);
      if (Number.isFinite(savedDelay)) {
        state.settings.keyDelayMs = savedDelay;
        delayInput.value = String(savedDelay);
      }
      // å˜æ›´å³ä¿å­˜
      delayInput.addEventListener('change', () => {
        const v = parseInt(delayInput.value, 10);
        if (Number.isFinite(v)) {
          state.settings.keyDelayMs = v;
          localStorage.setItem('keyDelayMs', String(v));
        } else {
          state.settings.keyDelayMs = 0;
          delayInput.value = '';
          localStorage.removeItem('keyDelayMs');
        }
      });

      // é”®ç›˜å¤åˆ¶/ç²˜è´´
      document.addEventListener('keydown', async (e) => {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC')>=0;
        const copyCombo = (isMac ? e.metaKey : e.ctrlKey) && e.key.toLowerCase() === 'c';
        const pasteCombo = (isMac ? e.metaKey : e.ctrlKey) && e.key.toLowerCase() === 'v';
        if (copyCombo) { e.preventDefault(); handleCopy(); }
        if (pasteCombo) { e.preventDefault(); await handlePaste(); }
        // ç©ºæ ¼ æ’­æ”¾/æš‚åœ
        if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
        // Fï¼šè®©"é€‰ä¸­è¡Œ"ä»æ­¤åˆ»å¼€å§‹ï¼ˆåŒ…å«æŒ‰é”®å»¶è¿Ÿï¼‰
        if (!e.repeat && e.key.toLowerCase() === 'f') {
          // è‹¥æ­£åœ¨ç¼–è¾‘è¾“å…¥æ¡†åˆ™ä¸è§¦å‘
          const tag = (e.target && e.target.tagName) || '';
          if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;

          e.preventDefault();
          await alignSelectedLineToNow();
        }
      });

      // åˆå§‹ï¼šè‹¥æœªåŠ è½½åª’ä½“ï¼Œä¹Ÿå…è®¸æ—¶é’Ÿæ’­æ”¾ï¼ˆä½†éœ€å¯¼å…¥ doc åæ‰èƒ½æ’­æ”¾ï¼‰
      $('#btnPlayPause').disabled = true;
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>

<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>.lys 歌词顺序编辑器（拖放版）</title>
  <!-- 可选：为跨域后端提供 API 基址，例如 https://your-backend.example.com -->
  <meta name="api-base" content="" />
  <style>
    :root {
      --bg: #f5f7fb;
      --card: #ffffff;
      --text: #1f2328;
      --muted: #6b7280;
      --border: #e5e7eb;
      --shadow: 0 1px 2px rgba(0,0,0,0.04), 0 4px 12px rgba(0,0,0,0.06);
      --primary: #2563eb;
      --primary-600: #1d4ed8;
      --primary-50: #eff6ff;
      --accent: #8b5cf6;
      --accent-50: #f5f3ff;
      --radius: 10px;
      --radius-sm: 8px;
      --radius-xs: 6px;
      --token: #f9fafb;
      --token-border: #e5e7eb;
      --token-hover: #eef2ff;
      --token-selected: #f3e8ff;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b0f15;
        --card: #0f1722;
        --text: #e5e7eb;
        --muted: #9aa4b2;
        --border: #1f2937;
        --shadow: 0 1px 2px rgba(0,0,0,0.5), 0 8px 24px rgba(0,0,0,0.45);
        --primary: #3b82f6;
        --primary-600: #2563eb;
        --primary-50: #0b1220;
        --accent: #a78bfa;
        --accent-50: #141327;
        --token: #0f1722;
        --token-border: #1f2937;
        --token-hover: #111827;
        --token-selected: #18122b;
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans', Arial, 'PingFang SC', 'Hiragino Sans GB', sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 800px at 10% -10%, rgba(37,99,235,0.05), transparent 40%),
                  radial-gradient(900px 600px at 100% 0%, rgba(139,92,246,0.06), transparent 45%),
                  var(--bg);
    }

    header {
      position: sticky; top: 0; z-index: 20;
      padding: 14px 18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.75)) no-repeat,
                  var(--card);
      backdrop-filter: saturate(1.2) blur(6px);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    @media (prefers-color-scheme: dark) {
      header { background: linear-gradient(180deg, rgba(15,23,34,0.8), rgba(15,23,34,0.75)) no-repeat, var(--card); }
    }

    h1 { margin: 0 0 10px 0; font-size: 20px; font-weight: 650; letter-spacing: 0.2px; }

    .controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .controls input[type=file] {
      padding: 6px 8px; border: 1px dashed var(--border); border-radius: var(--radius-xs);
      background: var(--card); color: var(--muted);
    }
    .controls button {
      padding: 8px 12px; border: 1px solid var(--border); background: var(--card);
      border-radius: var(--radius); cursor: pointer; color: var(--text);
      transition: background .2s ease, border-color .2s ease, box-shadow .2s ease, transform .06s ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    .controls button:hover { border-color: #cbd5e1; box-shadow: 0 4px 10px rgba(2,6,23,0.05); }
    .controls button:active { transform: translateY(1px); }
    .controls button:disabled { opacity: 0.6; cursor: not-allowed; }
    /* Primary emphasis */
    #btnImport, #btnExport {
      background: linear-gradient(180deg, var(--primary), var(--primary-600));
      color: #fff; border-color: transparent; box-shadow: 0 6px 18px rgba(37,99,235,0.25);
    }
    #btnImport:hover, #btnExport:hover { box-shadow: 0 8px 22px rgba(37,99,235,0.3); }
    #btnImport:disabled, #btnExport:disabled { background: #aab4c6; box-shadow: none; }

    main {
      display: grid; grid-template-columns: minmax(0, 1fr) 360px; gap: 18px; padding: 18px; max-width: 1200px; margin: 0 auto;
    }
    @media (max-width: 980px) {
      main { grid-template-columns: 1fr; }
    }

    .panel {
      border: 1px solid var(--border); border-radius: var(--radius); padding: 14px; background: var(--card);
      box-shadow: var(--shadow);
    }
    .panel > h2 { margin: 2px 0 10px; font-size: 16px; color: var(--muted); font-weight: 600; }

    #docInfo { color: var(--muted); margin-bottom: 10px; font-size: 13px; }

    #lines { display: flex; flex-direction: column; gap: 10px; }

    .line {
      display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
      padding: 10px; border: 1px dashed var(--border); border-radius: var(--radius-sm);
      background: color-mix(in srgb, var(--card) 92%, transparent);
      transition: border-color .2s ease, background .2s ease, box-shadow .2s ease;
    }
    .line:hover { border-color: #cbd5e1; box-shadow: 0 2px 10px rgba(2,6,23,0.04); }
    .line.meta { background: var(--primary-50); border-style: solid; }

    .prefix { color: var(--muted); margin-right: 6px; font-variant-numeric: tabular-nums; }

    .tok {
      display: inline-block; padding: 6px 10px; border: 1px solid var(--token-border);
      border-radius: 999px; cursor: grab; user-select: none;
      background: var(--token); color: var(--text);
      transition: border-color .15s ease, box-shadow .15s ease, background .15s ease, transform .06s ease;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
      outline: none;
    }
    .tok:hover { border-color: #c7d2fe; background: var(--token-hover); }
    .tok:active { cursor: grabbing; transform: translateY(1px); }
    .tok.selected {
      background: var(--token-selected);
      border-color: #c084fc;
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent);
    }
    .tok.anchor { outline: 2px solid var(--primary); }
    .tok:focus-visible { box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 30%, transparent); }

    .tok.drop-left { box-shadow: -3px 0 0 0 var(--primary) inset, 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
    .tok.drop-right { box-shadow:  3px 0 0 0 var(--primary) inset, 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }

    .box { background: linear-gradient(180deg, var(--accent-50), transparent 80%); padding: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); }
    #status { margin-top: 10px; color: var(--muted); min-height: 1.4em; font-size: 13px; }
    .muted { color: var(--muted); font-size: 12px; }

    /* Smooth scrollbars */
    ::-webkit-scrollbar { height: 10px; width: 10px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 999px; }
    ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

    /* Line drop highlight */
    .line.drop-left { box-shadow: inset 4px 0 0 0 var(--primary); border-style: solid; }
    .line.drop-right { box-shadow: inset -4px 0 0 0 var(--primary); border-style: solid; }
    .line.selected { border-color: #93c5fd; background: color-mix(in srgb, var(--primary-50) 65%, var(--card)); }

    /* Prefix editor */
    .prefix-editor { width: 64px; min-width: 56px; padding: 4px 6px; border: 1px dashed var(--border); border-radius: 7px; background: var(--card); color: var(--text); text-align: center; font-variant-numeric: tabular-nums; }
    .prefix-editor::placeholder { color: var(--muted); }
    .prefix-editor:focus { outline: none; border-color: #cbd5e1; box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
    /* Playing highlight */
    .tok.active {
      background: #fef3c7; /* amber-100 */
      border-color: #f59e0b; /* amber-500 */
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25);
    }
    .line.playing {
      outline: 2px solid rgba(245, 158, 11, 0.35);
    }
  </style>
</head>
<body>
  <header>
    <h1>.lys 歌词顺序编辑器（多选拖放，前端不显示时间戳）</h1>
    <div class="controls">
      <input type="file" id="fileInput" accept=".lys,.lrc,.txt" />
      <button id="btnImport">导入 .lys</button>
      <button id="btnUndo" disabled>撤销</button>
      <button id="btnRedo" disabled>重做</button>
      <button id="btnExport" disabled>导出 .lys</button>
      <span style="flex:1"></span>
      <input type="file" id="mediaInput" accept="audio/*,video/*" />
      <button id="btnPlayPause" disabled>播放</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2>文档</h2>
      <div id="docInfo"></div>
      <div id="lines"></div>
    </section>

    <section class="panel">
      <h2>用法</h2>
      <div class="box">
        <p>① <strong>Ctrl/⌘ 多选</strong>歌词块；或只选一个。</p>
        <p>② 把选中的块<strong>直接拖动</strong>到另一行的某个块上；根据鼠标落点在该块的左半/右半，决定插入到<strong>前面/后面</strong>。</p>
        <p class="muted">提示：页面不显示时间戳，但时间戳会随 token 一起移动；导出时时间戳会保留。</p>
        <p>③ 可选加载 <strong>音频/视频</strong> 文件，点击「播放」或空格，歌词将按 (开始时间, 持续时长) 高亮；<strong>单击任意一行</strong>可从该行开始播放。</p>
      </div>
      <div id="status"></div>
    </section>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    // API 基址（默认同源）。可在部署到 GitHub Pages 时，通过注入 window.API_BASE 或设置 <meta name="api-base" content="..."> 来指定后端域名。
    const API_BASE = (window.API_BASE || (document.querySelector('meta[name="api-base"]')?.content || '')).replace(/\/$/, '');
    const apiUrl = (path) => API_BASE + path;
    const apiFetch = (path, init) => fetch(apiUrl(path), init);

    let state = {
      doc: null,
      selectedTokenIds: new Set(),
      selectedLineId: null, // 选中的整行（用于行级复制/粘贴）
      clipboard: null,      // { tokens: [{text, ts}], fromLineId }
      // 播放相关
      playback: {
        usingMedia: false,
        mediaEl: null,
        playing: false,
        rafId: 0,
        clockStartEpoch: 0,
        clockStartOffset: 0, // ms
      },
      tokenCache: [], // [{id, lineId, start, end, el}]
    };

    function setStatus(msg) {
      $('#status').textContent = msg || '';
    }

    function renderDoc() {
      const c = $('#lines');
      c.innerHTML = '';
      if (!state.doc) return;
      $('#docInfo').textContent = `DocID: ${state.doc.id} — version: ${state.doc.version} — 行数: ${state.doc.lines.length}`;

      state.tokenCache = [];
      state.doc.lines.forEach((line) => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'line' + (line.is_meta ? ' meta' : '');
        lineDiv.dataset.lineId = line.id;
        if (state.selectedLineId === line.id) lineDiv.classList.add('selected');

        // 可编辑的前缀数字输入（仅非 meta 行）
        if (!line.is_meta) {
          const preWrap = document.createElement('div');
          preWrap.className = 'prefix';
          const input = document.createElement('input');
          input.className = 'prefix-editor';
          input.type = 'number';
          input.placeholder = '[ ]';
          const m = /\[([^\]]*)\]/.exec(line.prefix || '');
          input.value = m ? m[1] : '';
          input.title = '可编辑的前缀数字（留空为无前缀）';
          input.addEventListener('click', (e) => { e.stopPropagation(); });
          input.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') { await commitPrefix(line.id, input.value); }
            e.stopPropagation();
          });
          input.addEventListener('blur', async () => { await commitPrefix(line.id, input.value); });
          preWrap.appendChild(input);
          lineDiv.appendChild(preWrap);
        } else if (line.prefix) {
          const pre = document.createElement('span');
          pre.className = 'prefix';
          pre.textContent = line.prefix;
          lineDiv.appendChild(pre);
        }

        line.tokens.forEach((tok) => {
          const span = document.createElement('span');
          span.className = 'tok';
          // 不显示时间戳，只显示文本
          span.textContent = tok.text || '(空)';
          span.title = `tokenId=${tok.id}`; // 不显示时间戳
          span.dataset.tokenId = tok.id;
          span.dataset.lineId = line.id;
          span.draggable = !line.is_meta;  // meta 行不允许拖拽

          // 解析时间戳（start,duration）
          let sMs = null, dMs = null;
          if (tok.ts && typeof tok.ts === 'string' && tok.ts.includes(',')) {
            const parts = tok.ts.split(',');
            sMs = parseInt(parts[0], 10);
            dMs = parseInt(parts[1], 10);
            if (!Number.isFinite(sMs) || !Number.isFinite(dMs)) { sMs = null; dMs = null; }
          }
          if (sMs != null && dMs != null) {
            span.dataset.startMs = String(sMs);
            span.dataset.durMs = String(dMs);
            state.tokenCache.push({ id: tok.id, lineId: line.id, start: sMs, end: sMs + dMs, el: span });
          }

          if (state.selectedTokenIds.has(tok.id)) span.classList.add('selected');

          // 点击：多选/取消
          span.addEventListener('click', (e) => {
            const multi = e.metaKey || e.ctrlKey;
            if (multi) {
              if (state.selectedTokenIds.has(tok.id)) state.selectedTokenIds.delete(tok.id);
              else state.selectedTokenIds.add(tok.id);
            } else {
              // 单击切换选择到这个 token（便于单选拖动）
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
            }
            renderDoc();
          });

          // 拖拽开始：若当前 token 不在选择中，则将选择重置为该 token
          span.addEventListener('dragstart', (e) => {
            if (!state.selectedTokenIds.has(tok.id)) {
              state.selectedTokenIds.clear();
              state.selectedTokenIds.add(tok.id);
              renderDoc();
            }
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', 'drag'); // 占位以启用拖拽
          });

          // 在 token 上方悬停：决定 before / after 的视觉提示
          span.addEventListener('dragover', (e) => {
            if (!state.doc) return;
            e.preventDefault(); // 允许 drop
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.toggle('drop-left', isLeft);
            span.classList.toggle('drop-right', !isLeft);
          });

          // 离开时清理样式
          span.addEventListener('dragleave', () => {
            span.classList.remove('drop-left', 'drop-right');
          });

          // 放下：计算 before/after，构造 selection + target，调用 /api/move
          span.addEventListener('drop', async (e) => {
            e.preventDefault();
            const rect = span.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            span.classList.remove('drop-left', 'drop-right');
            await doDropMove({
              anchorLineId: span.dataset.lineId,
              anchorTokenId: span.dataset.tokenId,
              position: isLeft ? 'before' : 'after',
            });
          });

          lineDiv.appendChild(span);
        });

        // 行级交互：选择行、行级拖放（到头/尾）、双击插入空行
        if (!line.is_meta) {
          lineDiv.addEventListener('click', (e) => {
            if (e.target.classList.contains('tok') || e.target.classList.contains('prefix-editor')) return;
            state.selectedTokenIds.clear();
            state.selectedLineId = line.id;
            renderDoc();
            // 单击行：从该行开始播放
            startFromLine(line.id);
          });

          lineDiv.addEventListener('dblclick', async (e) => {
            e.preventDefault();
            await insertEmptyLineBelow(line.id);
          });

          lineDiv.addEventListener('dragover', (e) => {
            if (!state.doc) return; e.preventDefault();
            const rect = lineDiv.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            lineDiv.classList.toggle('drop-left', isLeft);
            lineDiv.classList.toggle('drop-right', !isLeft);
          });
          lineDiv.addEventListener('dragleave', () => {
            lineDiv.classList.remove('drop-left', 'drop-right');
          });
          lineDiv.addEventListener('drop', async (e) => {
            e.preventDefault();
            const rect = lineDiv.getBoundingClientRect();
            const isLeft = (e.clientX - rect.left) < rect.width / 2;
            lineDiv.classList.remove('drop-left', 'drop-right');
            await doDropMoveLine({ lineId: line.id, position: isLeft ? 'start' : 'end' });
          });
        }

        c.appendChild(lineDiv);
      });
      // 渲染后刷新一次高亮（保持播放中时 UI 同步）
      updateHighlight(getNowMs());
    }

    // 将选中的 token ID 集合合并成若干个 [start_id, end_id] 的连续区间（逐行）
    function groupSelectionIntoRanges() {
      if (!state.doc) return [];
      const idToIndex = new Map();
      state.doc.lines.forEach((line, li) => {
        line.tokens.forEach((tok, ti) => {
          idToIndex.set(tok.id, { li, ti, line_id: line.id });
        });
      });

      const selected = Array.from(state.selectedTokenIds)
        .map((id) => idToIndex.get(id))
        .filter(Boolean)
        .sort((a, b) => (a.li - b.li) || (a.ti - b.ti));

      const ranges = [];
      let i = 0;
      while (i < selected.length) {
        const { li, line_id } = selected[i];
        let startTi = selected[i].ti;
        let endTi = startTi;

        let j = i + 1;
        while (j < selected.length && selected[j].li === li && selected[j].ti === endTi + 1) {
          endTi = selected[j].ti;
          j++;
        }
        const line = state.doc.lines[li];
        const start_token_id = line.tokens[startTi].id;
        const end_token_id = line.tokens[endTi].id;
        ranges.push({ line_id, start_token_id, end_token_id });
        i = j;
      }
      return ranges;
    }

    async function doDropMove({ anchorLineId, anchorTokenId, position }) {
      if (!state.doc) return;
      const selectionRanges = groupSelectionIntoRanges();
      if (selectionRanges.length === 0) {
        setStatus('请先选择要移动的歌词块（可 Ctrl/⌘ 多选）');
        return;
      }

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        selection: selectionRanges,
        target: {
          type: 'anchor',
          line_id: anchorLineId,
          anchor_token_id: anchorTokenId,
          position: position // 'before' | 'after'
        }
      };

      const res = await apiFetch('/api/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setStatus('移动失败：' + text);
        return;
      }
      const doc = await res.json();
      state.doc = doc;
      // 成功后默认清空选择，避免误拖
      state.selectedTokenIds.clear();
      renderDoc();
      setStatus('已完成拖放移动。');
    }

    async function doDropMoveLine({ lineId, position }) {
      if (!state.doc) return;
      const selectionRanges = groupSelectionIntoRanges();
      if (selectionRanges.length === 0) { setStatus('请先选择要移动的歌词块（可 Ctrl/⌘ 多选）'); return; }

      const payload = {
        document_id: state.doc.id,
        base_version: state.doc.version,
        selection: selectionRanges,
        target: { type: 'line', line_id: lineId, position } // 'start' | 'end'
      };
      const res = await apiFetch('/api/move', {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
      });
      if (!res.ok) { const text = await res.text(); setStatus('移动失败：' + text); return; }
      const doc = await res.json();
      state.doc = doc; state.selectedTokenIds.clear(); renderDoc(); setStatus('已完成拖放移动。');
    }

    async function insertEmptyLineBelow(afterLineId) {
      const res = await apiFetch('/api/newline', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, insert_after_line_id: afterLineId })
      });
      if (!res.ok) { const text = await res.text(); setStatus('插入空行失败：' + text); return; }
      const doc = await res.json(); state.doc = doc; renderDoc(); setStatus('已插入空行。');
    }

    async function commitPrefix(lineId, value) {
      if (!state.doc) return;
      const v = String(value || '').trim();
      const res = await apiFetch('/api/set_prefix', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, line_id: lineId, prefix_int: v === '' ? '[]' : v })
      });
      if (!res.ok) { return; }
      const doc = await res.json(); state.doc = doc; renderDoc();
    }

    function collectSelectedTokens() {
      if (!state.doc) return [];
      const idToTok = new Map();
      const order = [];
      state.doc.lines.forEach((line, li) => {
        line.tokens.forEach((tok, ti) => {
          idToTok.set(tok.id, { tok, li, ti, line_id: line.id });
          order.push({ id: tok.id, li, ti });
        });
      });
      const arr = Array.from(state.selectedTokenIds).map(id => idToTok.get(id)).filter(Boolean);
      arr.sort((a,b)=> (a.li-b.li)||(a.ti-b.ti));
      return arr;
    }

    function handleCopy() {
      const sels = collectSelectedTokens();
      if (sels.length > 0) {
        const tokens = sels.map(s => ({ text: s.tok.text, ts: s.tok.ts }));
        state.clipboard = { tokens, fromLineId: sels[0].line_id };
        setStatus('已复制所选歌词块。');
        return true;
      }
      if (state.selectedLineId) {
        const line = state.doc.lines.find(ln => ln.id === state.selectedLineId);
        if (line && !line.is_meta && line.tokens.length) {
          const tokens = line.tokens.map(t => ({ text: t.text, ts: t.ts }));
          state.clipboard = { tokens, fromLineId: line.id };
          setStatus('已复制整行歌词。');
          return true;
        }
      }
      setStatus('没有可复制的内容');
      return false;
    }

    async function handlePaste() {
      if (!state.clipboard || !state.doc) { setStatus('剪贴板为空'); return; }
      const items = state.clipboard.tokens || [];
      if (items.length === 0) { setStatus('剪贴板为空'); return; }

      // 优先：若选中了 token，则粘贴到其右边（取该行中选中的最右一个 token 索引+1）
      const sels = collectSelectedTokens();
      if (sels.length > 0) {
        const lineId = sels[0].line_id;
        const line = state.doc.lines.find(ln => ln.id === lineId);
        const lastTi = Math.max(...sels.filter(s=>s.line_id===lineId).map(s=>s.ti));
        await insertTokens(lineId, lastTi + 1, items);
        return;
      }
      // 否则：若选中行，则粘贴到该行最左
      if (state.selectedLineId) {
        await insertTokens(state.selectedLineId, 0, items);
        return;
      }
      setStatus('请先选中一个目标（token或行）再粘贴');
    }

    async function insertTokens(lineId, insertAt, tokens) {
      const res = await apiFetch('/api/insert_tokens', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_id: state.doc.id, base_version: state.doc.version, line_id: lineId, insert_at: insertAt, tokens })
      });
      if (!res.ok) { const text = await res.text(); setStatus('粘贴失败：' + text); return; }
      const doc = await res.json(); state.doc = doc; state.selectedTokenIds.clear(); renderDoc(); setStatus('已粘贴。');
    }

    // ---- 基础 API 调用（导入、导出、撤销、重做） ----
    async function importLys(file) {
      const fd = new FormData();
      fd.append('file', file);
      const res = await apiFetch('/api/import', { method: 'POST', body: fd });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || '导入失败');
      }
      const doc = await res.json();
      state.doc = doc;
      state.selectedTokenIds.clear();
      renderDoc();
      $('#btnExport').disabled = false;
      $('#btnUndo').disabled = false;
      $('#btnRedo').disabled = false;
      // 允许在无媒体文件时使用时钟播放
      $('#btnPlayPause').disabled = false;
    }

    async function exportLys() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/export?' + params.toString(), { method: 'GET' });
      const text = await res.text();
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'edited.lys';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    async function undo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/undo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('无法撤销'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
    }

    async function redo() {
      const params = new URLSearchParams({ doc_id: state.doc.id });
      const res = await apiFetch('/api/redo?' + params.toString(), { method: 'POST' });
      if (!res.ok) { setStatus('无法重做'); return; }
      const doc = await res.json();
      state.doc = doc;
      renderDoc();
    }

    // ======== 播放器逻辑 ========
    function ensureMediaEl() {
      if (!state.playback.mediaEl) {
        const v = document.createElement('video');
        v.id = 'player';
        v.controls = true; // 允许用户控制
        v.style.maxWidth = '100%';
        v.style.display = 'block';
        v.style.marginTop = '10px';
        // 放到用法面板下（更自然）
        const panel = document.querySelectorAll('.panel')[1];
        panel.appendChild(v);
        state.playback.mediaEl = v;
        // 当媒体播放/暂停时，同步按钮状态
        v.addEventListener('play', () => { state.playback.playing = true; startLoop(); syncPlayButton(); });
        v.addEventListener('pause', () => { state.playback.playing = false; stopLoop(); syncPlayButton(); });
        v.addEventListener('seeked', () => { updateHighlight(getNowMs()); });
        v.addEventListener('timeupdate', () => { updateHighlight(getNowMs()); });
        v.addEventListener('ended', () => { state.playback.playing = false; stopLoop(); syncPlayButton(); });
      }
      return state.playback.mediaEl;
    }

    function loadMediaFile(file) {
      const v = ensureMediaEl();
      const url = URL.createObjectURL(file);
      v.src = url;
      v.load();
      state.playback.usingMedia = true;
      $('#btnPlayPause').disabled = false;
      setStatus('已加载媒体：' + (file.name || '')); 
    }

    function getNowMs() {
      if (state.playback.usingMedia && state.playback.mediaEl) {
        return (state.playback.mediaEl.currentTime || 0) * 1000;
      }
      // 时钟模式
      return state.playback.clockStartOffset + (state.playback.playing ? (performance.now() - state.playback.clockStartEpoch) : 0);
    }

    function play() {
      if (!state.doc) { setStatus('请先导入 .lys'); return; }
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.play();
      } else {
        // 无媒体，使用时钟
        state.playback.playing = true;
        state.playback.clockStartEpoch = performance.now();
        startLoop();
        syncPlayButton();
      }
    }

    function pause() {
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.pause();
      } else {
        // 时钟暂停
        state.playback.clockStartOffset = getNowMs();
        state.playback.playing = false;
        stopLoop();
        syncPlayButton();
      }
    }

    function togglePlay() {
      if (state.playback.playing) pause(); else play();
    }

    function seekMs(ms) {
      ms = Math.max(0, ms|0);
      if (state.playback.usingMedia && state.playback.mediaEl) {
        state.playback.mediaEl.currentTime = ms / 1000;
      } else {
        state.playback.clockStartOffset = ms;
        if (state.playback.playing) state.playback.clockStartEpoch = performance.now();
        updateHighlight(getNowMs());
      }
    }

    function startFromLine(lineId) {
      if (!state.doc) return;
      const line = state.doc.lines.find(l => l.id === lineId);
      if (!line || !line.tokens || line.tokens.length === 0) return;
      // 找到该行最早的 start
      let minStart = Infinity;
      for (const t of line.tokens) {
        if (!t.ts) continue;
        const [s, d] = String(t.ts).split(',').map(x=>parseInt(x,10));
        if (Number.isFinite(s)) minStart = Math.min(minStart, s);
      }
      if (!Number.isFinite(minStart)) return;
      seekMs(minStart);
      // 若未播放则开始
      if (!state.playback.playing) play();
    }

    function syncPlayButton() {
      $('#btnPlayPause').textContent = state.playback.playing ? '暂停' : '播放';
    }

    function startLoop() {
      cancelAnimationFrame(state.playback.rafId);
      const loop = () => {
        updateHighlight(getNowMs());
        state.playback.rafId = requestAnimationFrame(loop);
      };
      state.playback.rafId = requestAnimationFrame(loop);
    }

    function stopLoop() {
      cancelAnimationFrame(state.playback.rafId);
    }

    function updateHighlight(nowMs) {
      // 高亮 token，及其所在行
      const activeLines = new Set();
      for (const item of state.tokenCache) {
        const active = nowMs >= item.start && nowMs < item.end;
        item.el.classList.toggle('active', !!active);
        if (active) activeLines.add(item.lineId);
      }
      // 行级标记
      document.querySelectorAll('.line').forEach(ln => {
        const lid = ln.dataset.lineId;
        ln.classList.toggle('playing', activeLines.has(lid));
      });
    }

    function init() {
      $('#btnImport').addEventListener('click', async () => {
        const f = $('#fileInput').files[0];
        if (!f) { setStatus('请选择一个 .lys 文件'); return; }
        try {
          await importLys(f);
          setStatus('导入成功。');
        } catch (e) {
          setStatus(String(e));
        }
      });

      $('#btnExport').addEventListener('click', exportLys);
      $('#btnUndo').addEventListener('click', undo);
      $('#btnRedo').addEventListener('click', redo);
      $('#btnPlayPause').addEventListener('click', togglePlay);
      $('#mediaInput').addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (f) loadMediaFile(f);
      });

      // 点击空白处清空选择
      $('#lines').addEventListener('click', (e) => {
        if (e.target.classList.contains('tok') || e.target.classList.contains('prefix-editor')) return;
        state.selectedTokenIds.clear();
        state.selectedLineId = null;
        renderDoc();
      });

      // 键盘复制/粘贴
      document.addEventListener('keydown', async (e) => {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC')>=0;
        const copyCombo = (isMac ? e.metaKey : e.ctrlKey) && e.key.toLowerCase() === 'c';
        const pasteCombo = (isMac ? e.metaKey : e.ctrlKey) && e.key.toLowerCase() === 'v';
        if (copyCombo) { e.preventDefault(); handleCopy(); }
        if (pasteCombo) { e.preventDefault(); await handlePaste(); }
        // 空格 播放/暂停
        if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
      });

      // 初始：若未加载媒体，也允许时钟播放（但需导入 doc 后才能播放）
      $('#btnPlayPause').disabled = true;
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
